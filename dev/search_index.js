var documenterSearchIndex = {"docs":
[{"location":"models.html#model_section-1","page":"1. Setting up a Dynamics Model","title":"1. Setting up a Dynamics Model","text":"","category":"section"},{"location":"models.html#","page":"1. Setting up a Dynamics Model","title":"1. Setting up a Dynamics Model","text":"CurrentModule = RobotDynamics","category":"page"},{"location":"models.html#","page":"1. Setting up a Dynamics Model","title":"1. Setting up a Dynamics Model","text":"Pages = [\"models.md\"]","category":"page"},{"location":"models.html#Overview-1","page":"1. Setting up a Dynamics Model","title":"Overview","text":"","category":"section"},{"location":"models.html#","page":"1. Setting up a Dynamics Model","title":"1. Setting up a Dynamics Model","text":"The Model type holds information about the dynamics of the system. All dynamics are assumed to be state-space models of the system of the form dotx = f(xu) where dotx is the state derivative, x an n-dimensional state vector, and u in an m-dimensional control input vector. The function f can be any nonlinear function.","category":"page"},{"location":"models.html#","page":"1. Setting up a Dynamics Model","title":"1. Setting up a Dynamics Model","text":"Many numerical methods require discrete dynamics of the form x_k+1 = f(x_k u_k), where k is the time step. There many methods of performing this discretization, and RobotDynamics.jl offers several of the most common methods. See Model Discretization section for more information on discretizing dynamics, as well as how to define custom integration methods.","category":"page"},{"location":"models.html#Creating-a-New-Model-1","page":"1. Setting up a Dynamics Model","title":"Creating a New Model","text":"","category":"section"},{"location":"models.html#","page":"1. Setting up a Dynamics Model","title":"1. Setting up a Dynamics Model","text":"To create a new model of a dynamical system, you need to define a new type that inherits from AbstractModel. You will need to then define only a few methods on your type. Let's say we want to create a model of the canonical cartpole. We start by defining our type:","category":"page"},{"location":"models.html#","page":"1. Setting up a Dynamics Model","title":"1. Setting up a Dynamics Model","text":"struct Cartpole{T} <: AbstractModel\n    mc::T  # mass of the cart\n    mp::T  # mass of the pole\n    l::T   # length of the pole\n    g::T   # gravity\nend","category":"page"},{"location":"models.html#","page":"1. Setting up a Dynamics Model","title":"1. Setting up a Dynamics Model","text":"It's often convenient to store any model parameters inside the new type (make sure they're concrete types!). If you need to store vectors or matrices, we highly recommend using StaticArrays, which are extremely fast and avoid memory allocations. For models with lots of parameters, we recommend Parameters.jl that makes it easy to specify default parameters.","category":"page"},{"location":"models.html#","page":"1. Setting up a Dynamics Model","title":"1. Setting up a Dynamics Model","text":"We now just need to define two functions to complete the interface","category":"page"},{"location":"models.html#","page":"1. Setting up a Dynamics Model","title":"1. Setting up a Dynamics Model","text":"import RobotDynamics: dynamics  # the dynamics function must be imported\n\nfunction dynamics(model::Cartpole, x, u)\n    mc = model.mc   # mass of the cart in kg (10)\n    mp = model.mp   # mass of the pole (point mass at the end) in kg\n    l = model.l     # length of the pole in m\n    g = model.g     # gravity m/s^2\n\n    q  = x[SA[1,2]]\n    qd = x[SA[3,4]]\n\n    s = sin(q[2])\n    c = cos(q[2])\n\n    H = SA[mc+mp mp*l*c; mp*l*c mp*l^2]\n    C = SA[0 -mp*qd[2]*l*s; 0 0]\n    G = SA[0, mp*g*l*s]\n    B = SA[1, 0]\n\n    qdd = -H\\(C*qd + G - B*u[1])\n    return [qd; qdd]\nend\n\nRobotDynamics.state_dim(::Cartpole) = 4\nRobotDynamics.control_dim(::Cartpole) = 1","category":"page"},{"location":"models.html#","page":"1. Setting up a Dynamics Model","title":"1. Setting up a Dynamics Model","text":"And voila! we have a new model.","category":"page"},{"location":"models.html#","page":"1. Setting up a Dynamics Model","title":"1. Setting up a Dynamics Model","text":"We now have a few methods automatically available to us:","category":"page"},{"location":"models.html#","page":"1. Setting up a Dynamics Model","title":"1. Setting up a Dynamics Model","text":"dynamics\njacobian!","category":"page"},{"location":"models.html#RobotDynamics.dynamics","page":"1. Setting up a Dynamics Model","title":"RobotDynamics.dynamics","text":"ẋ = dynamics(model, z::AbstractKnotPoint)\nẋ = dynamics(model, x, u, [t=0])\n\nCompute the continuous dynamics of a forced dynamical given the states x, controls u and time t (optional).\n\n\n\n\n\n","category":"function"},{"location":"models.html#RobotDynamics.jacobian!","page":"1. Setting up a Dynamics Model","title":"RobotDynamics.jacobian!","text":"∇f = jacobian!(∇f, model, z::AbstractKnotPoint)\n\nCompute the n × (n + m) Jacobian ∇f of the continuous-time dynamics using ForwardDiff. Only accepts an AbstractKnotPoint as input in order to avoid potential allocations associated with concatenation.\n\n\n\n\n\n","category":"function"},{"location":"models.html#","page":"1. Setting up a Dynamics Model","title":"1. Setting up a Dynamics Model","text":"We can also use size(model) to get (n,m), rand(model) to get a tuple of randomly-sampled state and control vectors, or zeros(model) to get 0-vectors of the state and control.","category":"page"},{"location":"models.html#Analytical-Jacobians-1","page":"1. Setting up a Dynamics Model","title":"Analytical Jacobians","text":"","category":"section"},{"location":"models.html#","page":"1. Setting up a Dynamics Model","title":"1. Setting up a Dynamics Model","text":"Instead of relying on ForwardDiff to generate our dynamics Jacobian, we can instead overwrite the method ourselves by defining the function:","category":"page"},{"location":"models.html#","page":"1. Setting up a Dynamics Model","title":"1. Setting up a Dynamics Model","text":"jacobian!(∇f, model::Cartpole, z::AbstractKnotPoint)","category":"page"},{"location":"models.html#","page":"1. Setting up a Dynamics Model","title":"1. Setting up a Dynamics Model","text":"where ∇f is a n × (n+m) matrix and z is an AbstractKnotPoint.","category":"page"},{"location":"models.html#","page":"1. Setting up a Dynamics Model","title":"1. Setting up a Dynamics Model","text":"warning: Warning\nBy default, RobotDynamics will NOT use the analytical continuous Jacobian when computing the discrete Jacobian, since our benchmarks have shown it is typically faster to let ForwardDiff compute the Jacobian directly on the discrete dynamics function, thereby avoiding multiple calls to jacobian!.","category":"page"},{"location":"models.html#Time-varying-systems-1","page":"1. Setting up a Dynamics Model","title":"Time-varying systems","text":"","category":"section"},{"location":"models.html#","page":"1. Setting up a Dynamics Model","title":"1. Setting up a Dynamics Model","text":"RobotDynamics.jl also offers support for time-varying systems. Let's say for some reason the mass of our cartpole is decreasing linearly with time. We can model this with a slight modification to the dynamics function signature:","category":"page"},{"location":"models.html#","page":"1. Setting up a Dynamics Model","title":"1. Setting up a Dynamics Model","text":"import RobotDynamics: dynamics\n\nstruct CartpoleTimeVarying{T} <: AbstractModel\n    mc::T  # initial mass of the cart\n    mp::T  # mass of the pole\n    l::T   # length of the pole\n    g::T   # gravity\nend\n\nfunction dynamics(model::CartpoleTimeVarying, x, u, t)  # note extra time parameter\n    mc = model.mc   # mass of the cart in kg (10)\n    mp = model.mp   # mass of the pole (point mass at the end) in kg\n    l = model.l     # length of the pole in m\n    g = model.g     # gravity m/s^2\n\n    # Change the mass of the cart with time\n    mc = mc - 0.01*t\n\n    q  = x[SA[1,2]]\n    qd = x[SA[3,4]]\n\n    s = sin(q[2])\n    c = cos(q[2])\n\n    H = SA[mc+mp mp*l*c; mp*l*c mp*l^2]\n    C = SA[0 -mp*qd[2]*l*s; 0 0]\n    G = SA[0, mp*g*l*s]\n    B = SA[1, 0]\n\n    qdd = -H\\(C*qd + G - B*u[1])\n    return [qd; qdd]\nend\n\nRobotDynamics.state_dim(::CartpoleTimeVarying) = 4\nRobotDynamics.control_dim(::CartpoleTimeVarying) = 1","category":"page"},{"location":"models.html#Models-with-3D-Rotations-1","page":"1. Setting up a Dynamics Model","title":"Models with 3D Rotations","text":"","category":"section"},{"location":"models.html#","page":"1. Setting up a Dynamics Model","title":"1. Setting up a Dynamics Model","text":"RobotDynamics.jl offers support for models with non-Euclidean state vectors, such as 3D rotations, which live in SO(3) instead of mathbbR^4 (quaternions) or mathbbR^3 (Euler angles, Modified Rodrigues Parameters, etc.). See RigidBody section for more details.","category":"page"},{"location":"discretization.html#","page":"Discretization","title":"Discretization","text":"CurrentModule =","category":"page"},{"location":"discretization.html#Discretization-1","page":"Discretization","title":"Discretization","text":"","category":"section"},{"location":"discretization.html#","page":"Discretization","title":"Discretization","text":"This page gives details on the methods for evaluating discretized dynamics, as well as instructions on how to define a custom integration method.","category":"page"},{"location":"discretization.html#Model-Discretization-1","page":"Discretization","title":"Model Discretization","text":"","category":"section"},{"location":"discretization.html#","page":"Discretization","title":"Discretization","text":"With a model defined, we can compute the discrete dynamics and discrete dynamics Jacobians for an Implicit integration rule with the following methods","category":"page"},{"location":"discretization.html#","page":"Discretization","title":"Discretization","text":"discrete_dynamics\ndiscrete_jacobian!","category":"page"},{"location":"discretization.html#RobotDynamics.discrete_dynamics","page":"Discretization","title":"RobotDynamics.discrete_dynamics","text":"Compute the discretized dynamics of model using explicit integration scheme Q<:QuadratureRule.\n\nMethods:\n\nx′ = discrete_dynamics(model, model, z)  # uses RK3 as the default integration scheme\nx′ = discrete_dynamics(Q, model, x, u, t, dt)\nx′ = discrete_dynamics(Q, model, z::KnotPoint)\n\nThe default integration scheme is stored in TrajectoryOptimization.DEFAULT_Q\n\n\n\n\n\n","category":"function"},{"location":"discretization.html#RobotDynamics.discrete_jacobian!","page":"Discretization","title":"RobotDynamics.discrete_jacobian!","text":"∇f = discrete_jacobian!(Q, ∇f, model, z::AbstractKnotPoint)\n\nCompute the n × (n+m) discrete dynamics Jacobian ∇f of model using explicit integration scheme Q<:QuadratureRule.\n\n\n\n\n\n","category":"function"},{"location":"discretization.html#Integration-Schemes-1","page":"Discretization","title":"Integration Schemes","text":"","category":"section"},{"location":"discretization.html#","page":"Discretization","title":"Discretization","text":"RobotDynamics.jl has already defined a handful of integration schemes for computing discrete dynamics. The integration schemes are specified as abstract types, so that methods can efficiently dispatch based on the integration scheme selected. Here is the current set of implemented types:","category":"page"},{"location":"discretization.html#","page":"Discretization","title":"Discretization","text":"QuadratureRule\nImplicit\nRK2\nRK3\nRK4\nExplicit\nHermiteSimpson","category":"page"},{"location":"discretization.html#","page":"Discretization","title":"Discretization","text":"QuadratureRule\nRobotDynamics.Explicit\nRK2\nRK3\nRK4\nRobotDynamics.Implicit\nHermiteSimpson","category":"page"},{"location":"discretization.html#RobotDynamics.QuadratureRule","page":"Discretization","title":"RobotDynamics.QuadratureRule","text":"Integration rule for approximating the continuous integrals for the equations of motion\n\n\n\n\n\n","category":"type"},{"location":"discretization.html#RobotDynamics.Explicit","page":"Discretization","title":"RobotDynamics.Explicit","text":"Integration rules of the form x′ = f(x,u), where x′ is the next state\n\n\n\n\n\n","category":"type"},{"location":"discretization.html#RobotDynamics.RK2","page":"Discretization","title":"RobotDynamics.RK2","text":"Second-order Runge-Kutta method with zero-order-old on the controls (i.e. midpoint)\n\n\n\n\n\n","category":"type"},{"location":"discretization.html#RobotDynamics.RK3","page":"Discretization","title":"RobotDynamics.RK3","text":"Second-order Runge-Kutta method with zero-order-old on the controls\n\n\n\n\n\n","category":"type"},{"location":"discretization.html#RobotDynamics.RK4","page":"Discretization","title":"RobotDynamics.RK4","text":"Fourth-order Runge-Kutta method with zero-order-old on the controls\n\n\n\n\n\n","category":"type"},{"location":"discretization.html#RobotDynamics.Implicit","page":"Discretization","title":"RobotDynamics.Implicit","text":"Integration rules of the form x′ = f(x,u,x′,u′), where x′,u′ are the states and controls at the next time step.\n\n\n\n\n\n","category":"type"},{"location":"discretization.html#RobotDynamics.HermiteSimpson","page":"Discretization","title":"RobotDynamics.HermiteSimpson","text":"Third-order Runge-Kutta method with first-order-hold on the controls\n\n\n\n\n\n","category":"type"},{"location":"discretization.html#Defining-a-New-Integration-Scheme-1","page":"Discretization","title":"Defining a New Integration Scheme","text":"","category":"section"},{"location":"discretization.html#Explicit-Methods-1","page":"Discretization","title":"Explicit Methods","text":"","category":"section"},{"location":"discretization.html#","page":"Discretization","title":"Discretization","text":"Explicit integration schemes are understandably simpler, since the output is not a function of itself, as is the case with implict schemes. As such, as a minimum, the user only needs to define the following method for a new rule MyQ:","category":"page"},{"location":"discretization.html#","page":"Discretization","title":"Discretization","text":"abstract type MyQ <: RobotDynamics.Explicit end\nx′ = discrete_dynamics(::Type{MyQ}, model::AbstractModel, x, u, dt)","category":"page"},{"location":"discretization.html#Implicit-Methods-(experimental)-1","page":"Discretization","title":"Implicit Methods (experimental)","text":"","category":"section"},{"location":"discretization.html#","page":"Discretization","title":"Discretization","text":"Incorporating implicit integration methods is still under development (great option for     someone looking to contribute!).","category":"page"},{"location":"liemodel.html#Models-with-Rotations-1","page":"Models with Rotations","title":"Models with Rotations","text":"","category":"section"},{"location":"liemodel.html#","page":"Models with Rotations","title":"Models with Rotations","text":"In robotics, the state of our robot often depends on one or more arbitrary 3D rotations (a.k.a. orientation, attitude). Effectively representing the non-trivial group structure of rotations has been a topic of student for over 100 years, and as a result many parameterizations exists. RobotDynamics supports the types defined in Rotations.jl.","category":"page"},{"location":"liemodel.html#","page":"Models with Rotations","title":"Models with Rotations","text":"The LieGroupModel type allows users to abstract away the particular rotation representation used and will automatically create efficient methods to handle the potentially different state dimensions that result. Additionally, it defines methods for operating on the error state, which for rotations is always three-dimensional. See the discussion in the Rotaitons.jl README for more information on the error state.","category":"page"},{"location":"liemodel.html#","page":"Models with Rotations","title":"Models with Rotations","text":"compat: Compat\nRobotDynamics requires v1.0 or higher of Rotations.jl","category":"page"},{"location":"liemodel.html#Defining-a-LieGroupModel-1","page":"Models with Rotations","title":"Defining a LieGroupModel","text":"","category":"section"},{"location":"liemodel.html#","page":"Models with Rotations","title":"Models with Rotations","text":"We define a LieGroupModel very similarly to that of a standard model. For this example, let's assume we are modeling a constellation of 2 satellites and we only care about the attitude dynamics. We will define our state to be [q1, ω1, q2, ω2] where qi and ωi are the orientation  and angular velocity of the ith satellite, respectively.","category":"page"},{"location":"liemodel.html#","page":"Models with Rotations","title":"Models with Rotations","text":"We start by defining our new type and our dynamics function","category":"page"},{"location":"liemodel.html#","page":"Models with Rotations","title":"Models with Rotations","text":"struct SatellitePair{R,T} <: LieGroupModel\n    J1::SMatrix{3,3,T,9}   # inertia of satellite 1\n    J2::SMatrix{3,3,T,9}   # inertia of satellite 2\nend\n\nfunction RobotDynamics.dynamics(model::SatellitePair, x, u)\n    vs = RobotDynamics.vec_states(model, x)  # extract \"vector\" states\n    qs = RobotDynamics.rot_states(model, x)  # extract attitude states\n    ω1 = vs[2]  # offset index by 1 since there are now \"vector\" states before the first quaternion\n    ω2 = vs[3]\n    q1 = qs[1]\n    q2 = qs[2]\n\n    J1, J2 = model.J1, model.J2\n    u1 = u[SA[1,2,3]]\n    u2 = u[SA[4,5,6]]\n    ω1dot = J1\\(u1 - ω1 × (J1 * ω1))\n    ω2dot = J2\\(u2 - ω2 × (J2 * ω2))\n    q1dot = Rotations.kinematics(q1, ω1)\n    q2dot = Rotations.kinematics(q2, ω2)\n    SA[\n        q1dot[1], q1dot[2], q1dot[3], q1dot[4],\n        ω1dot[1], ω1dot[2], ω1dot[3],\n        q2dot[1], q2dot[2], q2dot[3], q2dot[4],\n        ω2dot[1], ω2dot[2], ω2dot[3],\n    ]\nend\n\nRobotDynamics.control_dim(::SatellitePair) = 6","category":"page"},{"location":"liemodel.html#","page":"Models with Rotations","title":"Models with Rotations","text":"Before defining the functions vec_states and rot_states, we will define the type LieState, which defines how our state vector is stacked or partitioned. The LieState only needs to know how many \"vector\" or \"non-rotation\" states exist, and where the rotations are placed in the state vector. In our example, we have a rotation, followed by 3 \"vector\" states, followed by a rotation, followed by 3 \"vector\" states, so we would define our LieState to be","category":"page"},{"location":"liemodel.html#","page":"Models with Rotations","title":"Models with Rotations","text":"RobotDynamics.LieState(::SatellitePair{R}) where R = RobotDynamics.LieState(R, (0,3,3))","category":"page"},{"location":"liemodel.html#","page":"Models with Rotations","title":"Models with Rotations","text":"which means we have a state with 0 vector states at the beginning, followed by a rotation, followed by 3 vector states, followed by a rotation, followed by 3 vector states, and the rotation type is R.","category":"page"},{"location":"liemodel.html#","page":"Models with Rotations","title":"Models with Rotations","text":"With this partitioning in mind, we can now understand the behavior of vec_states and rot_states, which simply extract the vector and attitude parts of the state as tuples of SVectors.","category":"page"},{"location":"liemodel.html#LieGroupModel-API-1","page":"Models with Rotations","title":"LieGroupModel API","text":"","category":"section"},{"location":"liemodel.html#","page":"Models with Rotations","title":"Models with Rotations","text":"RobotDynamics.LieGroupModel\nRobotDynamics.LieState\nRobotDynamics.QuatState\nRobotDynamics.vec_states\nRobotDynamics.rot_states","category":"page"},{"location":"liemodel.html#RobotDynamics.LieGroupModel","page":"Models with Rotations","title":"RobotDynamics.LieGroupModel","text":"LieGroupModel <: AbstractModel\n\nAbstraction of a dynamical system whose state contains at least one arbitrary rotation.\n\n\n\n\n\n","category":"type"},{"location":"liemodel.html#RobotDynamics.LieState","page":"Models with Rotations","title":"RobotDynamics.LieState","text":"LieState{R,P}\n\nSpecifies a state with rotational components mixed in with standard vector components. All rotational components are assumed to be parameterizations of 3D rotations.\n\nParameters\n\nR <: Rotation is the rotational representation used in the state vector. Must have\n\nparams(::Type{R}) defined, which returns the number of parameters used by the rotation, as well a constructor that takes each parameter as a separate scalar argument.\n\nP <: Tuple{Vararg{Int}} is a tuple of integers specifying the partitioning of the state\n\nvector. Each element of P specifies the length of the vector component between the rotational components, and P[1] and P[end] specify the number of vector states at the beginning and end of the state vector.\n\nExamples\n\nIf we want to construct a state vector like the following: [v3, q, v2, q, v3] where v2 and v3 and vector components of length 2 and 3, respectively, and q is a 4-dimensional unit quaternion. The LieState for this state vector would be LieState{UnitQuaternion{Float64},3,2,3}. The length should be (3+4+2+4+3) = 16, which can be verified by length(s::LieState).\n\nConstructors\n\nLieState(::Type{R}, P::Tuple{Vararg{Int}})\nLieState(::Type{R}, p1::Int, p2::Int, p3::Int...)\n\n\n\n\n\n","category":"type"},{"location":"liemodel.html#RobotDynamics.QuatState","page":"Models with Rotations","title":"RobotDynamics.QuatState","text":"QuatState(n::Int, Q::StaticVector{<:Any,Int})\nQuatState(n::Int, Q::NTuple{<:Any,Int})\n\nCreate a n-dimensional LieState assuming R = UnitQuaternion{Float64} and Q[i] is the first index of each quaternion in the state vector.\n\nExample\n\nIf we want to construct a state vector like the following: [v3, q, v2, q, v3] where v2 and v3 and vector components of length 2 and 3, respectively, and q is a 4-dimensional unit quaternion. Since the first quaternion starts at index 4, and the second starts at index 10, Q = [4,10]. The entire length of the vector is n = 16 = 3 + 4 + 2 + 4 + 3, so we would call QuatState(16, SA[4,10]).\n\n\n\n\n\n","category":"function"},{"location":"liemodel.html#RobotDynamics.vec_states","page":"Models with Rotations","title":"RobotDynamics.vec_states","text":"vec_states(model::LieGroupModel, x)\nvec_states(s::LieState, x)\n\nExtracts the \"vector\" states out of the state vector x for a LieGroupModel. Returns a tuple v of SVectors, where length(v[i]) is equal to the length specified by the LieState.\n\n\n\n\n\n","category":"function"},{"location":"liemodel.html#RobotDynamics.rot_states","page":"Models with Rotations","title":"RobotDynamics.rot_states","text":"vec_states(model::LieGroupModel, x)\nvec_states(s::LieState, x)\n\nExtracts the rotations out of the state vector x for a LieGroupModel. Returns a tuple rotations, whose type matches the rotation type specified in the LieState.\n\n\n\n\n\n","category":"function"},{"location":"index.html#RobotDynamics.jl-1","page":"Introduction","title":"RobotDynamics.jl","text":"","category":"section"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"Welcome to RobotDynamics.jl! This package is dedicated to providing a convenient interface for defining the dynamics of forced dynamical systems, such as robots.","category":"page"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"This package also provides many efficient methods for evaluating dynamics, their Jacobians, and their discrete-time versions for use in the optimization routines packages such as TrajectoryOptimization.jl.","category":"page"},{"location":"knotpoints.html#KnotPoint-type-1","page":"KnotPoint type","title":"KnotPoint type","text":"","category":"section"},{"location":"knotpoints.html#","page":"KnotPoint type","title":"KnotPoint type","text":"CurrentModule = RobotDynamics","category":"page"},{"location":"knotpoints.html#","page":"KnotPoint type","title":"KnotPoint type","text":"A common way of dealing with trajectories of forced dynamical systems, especially in optimization, is to represent a trajectory with a fixed number of \"knot points\", typically distributed evenly over time. Each point records the states, controls, time, and time step to the next point. It is often convenient to store all this information together, which is the purpose of the AbstractKnotPoint type. Additionally, it is almost always more efficient to index into a concatenated vector than it is to concatenate two smaller vectors, so the states and controls are stacked together in a single  n+m-dimensional vector.","category":"page"},{"location":"knotpoints.html#","page":"KnotPoint type","title":"KnotPoint type","text":"RobotDynamics.jl defines a couple different implementations of the AbstractKnotPoint interface, which can be useful depending on the application.","category":"page"},{"location":"knotpoints.html#Types-1","page":"KnotPoint type","title":"Types","text":"","category":"section"},{"location":"knotpoints.html#","page":"KnotPoint type","title":"KnotPoint type","text":"AbstractKnotPoint\nGeneralKnotPoint\nKnotPoint\nStaticKnotPoint","category":"page"},{"location":"knotpoints.html#RobotDynamics.AbstractKnotPoint","page":"KnotPoint type","title":"RobotDynamics.AbstractKnotPoint","text":"AbstractKnotPoint{T,n,m}\n\nStores the states, controls, time, and time step at a single point along a trajectory of a forced dynamical system with n states and m controls.\n\nInterface\n\nAll instances of AbstractKnotPoint should support the following methods:\n\nstate(z)::StaticVector{n}     # state vector\ncontrol(z)::StaticVector{m}   # control vector\nz.t::Real                     # time\nz.dt::Real                    # time to next point (time step)\n\nBy default, it is assumed that if z.dt == 0 the point is the last point in the trajectory.\n\nAlternatively, the methods state and control will be automatically defined if the following fields are present:\n\nz.z: the stacked vector [x;u]\nz._x: the indices of the states, such that x = z.z[z._x]\nz._u: the indices of the controls, such that x = u.z[z._u]\n\n\n\n\n\n","category":"type"},{"location":"knotpoints.html#RobotDynamics.GeneralKnotPoint","page":"KnotPoint type","title":"RobotDynamics.GeneralKnotPoint","text":"GeneralKnotPoint{T,n,m,V} <: AbstractKnotPoint{T,n,m}\n\nA mutable instantiation of the AbstractKnotPoint interface where the joint vector z = [x;u] is represented by a type V.\n\nConstructors\n\nGeneralKnotPoint(n::Int, m::Int, z::AbstractVector, dt, [t=0])\nGeneralKnotPoint(z::V, _x::SVector{n,Int}, _u::SVector{m,Int}, dt::T, t::T)\nKnotPoint(z::V, _x::SVector{n,Int}, _u::SVector{m,Int}, dt::T, t::T)\n\n\n\n\n\n","category":"type"},{"location":"knotpoints.html#RobotDynamics.KnotPoint","page":"KnotPoint type","title":"RobotDynamics.KnotPoint","text":"KnotPoint{T,n,m,nm}\n\nA GeneralKnotPoint whose stacked vector z = [x;u] is represented by an SVector{nm,T} where nm = n+m.\n\nSetters\n\nUse the following methods to set values in a KnotPoint:\n\nset_state!(z::KnotPoint, x)\nset_control!(z::KnotPoint, u)\nz.t = t\nz.dt = dt\n\nConstructors\n\nKnotPoint(x, u, dt, [t=0.0])\nKnotPoint(x, m, [t=0.0])  # for terminal knot point\n\n\n\n\n\n","category":"type"},{"location":"knotpoints.html#RobotDynamics.StaticKnotPoint","page":"KnotPoint type","title":"RobotDynamics.StaticKnotPoint","text":"StaticKnotPoint{T,n,m,nm} <: AbstractKnotPoint{T,n,m}\n\nAn immutable AbstractKnotPoint whose stacked vector is represented by an SVector{nm,T} where nm = n+m. Since isbits(z::StaticKnotPoint) = true, these can be created very efficiently and with zero allocations.\n\nConstructors\n\nStaticKnotPoint(z::SVector{nm}, _x::SVector{n,Int}, _u::SVector{m,Int}, dt::Float64, t::Float64)\nStaticKnotPoint(x::SVector{n}, u::SVector{m}, [dt::Real=0.0, t::Real=0.0])\nStaticKnotPoint(z0::AbstractKnotPoint, z::AbstractVector)\n\nwhere the last constructor uses another AbstractKnotPoint to create a StaticKnotPoint using the stacked state-control vector z. If length(z) == n, the constructor will automatically append m zeros.\n\n\n\n\n\n","category":"type"},{"location":"knotpoints.html#Methods-1","page":"KnotPoint type","title":"Methods","text":"","category":"section"},{"location":"knotpoints.html#","page":"KnotPoint type","title":"KnotPoint type","text":"All AbstractKnotPoint types support the following methods:","category":"page"},{"location":"knotpoints.html#","page":"KnotPoint type","title":"KnotPoint type","text":"state\ncontrol\nis_terminal\nget_z\nset_state!\nset_control!\nset_z!","category":"page"},{"location":"knotpoints.html#RobotDynamics.state","page":"KnotPoint type","title":"RobotDynamics.state","text":"state(::AbstractKnotPoint)\n\nReturn the n-dimensional state vector\n\n\n\n\n\n","category":"function"},{"location":"knotpoints.html#RobotDynamics.control","page":"KnotPoint type","title":"RobotDynamics.control","text":"control(::AbstractKnotPoint)\n\nReturn the m-dimensional control vector\n\n\n\n\n\n","category":"function"},{"location":"knotpoints.html#RobotDynamics.is_terminal","page":"KnotPoint type","title":"RobotDynamics.is_terminal","text":"is_terminal(::AbstractKnotPoint)::Bool\n\nDetermine if the knot point is the terminal knot point, which is the case when z.dt == 0.\n\n\n\n\n\n","category":"function"},{"location":"knotpoints.html#RobotDynamics.get_z","page":"KnotPoint type","title":"RobotDynamics.get_z","text":"get_z(::AbstractKnotPoint)\n\nReturns the stacked state-control vector z, or just the state vector if is_terminal(z) == true.\n\n\n\n\n\n","category":"function"},{"location":"knotpoints.html#RobotDynamics.set_state!","page":"KnotPoint type","title":"RobotDynamics.set_state!","text":"set_state!(z::AbstractKnotPoint, x::AbstractVector)\n\nSet the state in z to x.\n\n\n\n\n\n","category":"function"},{"location":"knotpoints.html#RobotDynamics.set_control!","page":"KnotPoint type","title":"RobotDynamics.set_control!","text":"set_control!(z::AbstractKnotPoint, u::AbstractVector)\n\nSet the controls in z to u.\n\n\n\n\n\n","category":"function"},{"location":"knotpoints.html#RobotDynamics.set_z!","page":"KnotPoint type","title":"RobotDynamics.set_z!","text":"set_z!(z::AbstractKnotPoint, z_::AbstractVector)\n\nSet both the states and controls in z from the stacked state-control vector z_, unless is_terminal(z), in which case z_ is assumed to be the terminal states.\n\n\n\n\n\n","category":"function"},{"location":"knotpoints.html#Mathematical-Operations-1","page":"KnotPoint type","title":"Mathematical Operations","text":"","category":"section"},{"location":"knotpoints.html#","page":"KnotPoint type","title":"KnotPoint type","text":"All AbstractKnotPoint types support addition between two knot points, addition of a knot point and a vector of length n+m, and multiplication with a scalar, all of which will return a StaticKnotPoint.","category":"page"}]
}
